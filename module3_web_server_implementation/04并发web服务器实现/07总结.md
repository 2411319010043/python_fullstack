一、多进程实现HTTP服务器
    1.import multiprocessing
    2.创建套接字
    3.绑定端口
    4.设置为监听模式
    5.创建新的套接字，专门收发数据
    6.进程实例化 p1 = multiprocessing.Process(target= 收发数据函数名，args(参数，))
    7.p1.start()
    8.新套接字.close() 进程间不共享资源，p1中的新套接字关闭，主进程中的新套接字也要关闭
    
二、多线程实现HTTP服务器
    1.import threading
    2.创建套接字
    3.绑定端口
    4.设置为监听模式
    5.创建新的套接字，专门收发数据
    6.进程实例化 t1 = threading.Thread(target= 收发数据函数名，args(参数，))
    7.t1.start()
    
三、gevent实现HTTP服务器
    1.from gevent import monkey
      import gevent
    2.monkey.patch_all()
    3.创建套接字
    4.绑定端口
    5.设置为监听模式
    6.创建新的套接字，专门收发数据
    7.进程实例化 g1 = gevent.spawn(收发数据函数名，参数)
    8.g1.join()

四、单进程、单线程、非阻塞实现并发的原理
    将套接字设置成非堵塞的方式 采用轮询的方式
    外层用while True包裹 做死循环
        1. 检查监听套接字 有没有新的客户端来连接
        2. 将新的套接字都放入列表中 采用 for循环 依次查看有没有数据到来 直到客户端发送空字符 判断为数据发送完毕 从列表中移除套接字，关闭套接字

    结论：单进程单线程也是可以实现并发的 但缺点非常明显 如果客户端过多 那么循环一次的时间会被加长 效率过低

五、单进程、单线程、非阻塞、长连接实现并发的原理
    短连接：HTTP/1.0 一次请求 得到数据后 立即释放 每次请求都要三次握手四次挥手 效率低
    长连接：HTTP/1.1默认长连接，需通过Content-Length头精确控制数据边界 浏览器的请求头中有 keep-alive 

六、epoll Linux系统采用的一种特殊的机制
    让操作系统和程序共享一块内存 将fd存入epoll中 采用事件通知机制 
    1.创建一个epoll对象
    2.将监听套接字的fd注册到epoll中
    3.用一个字典来存放fd和对应的套接字，方便后续知道是那个套接字需要收发
    4.epl.poll默认会堵塞 直到有数据到来 才会解堵塞 返回一个列表嵌套元组的形式的返回值
    5.通过for循环依次取出fd,event做对比 看是哪个套接字需要收发
    6.收发完毕后 关闭套接字连接 注销epoll中的fd 删除字典里面的键值对



