一、多继承以及MRO顺序 
    1. 多继承与MRO顺序 
        1）多继承的基本概念
            继承方式：在Python中，多继承通过在类定义时写入多个父类名实现，如class Grandson(Son1, Son2)表示同时继承Son1和Son2两个父类。
            初始化顺序：子类实例化时会依次调用各父类的__init__方法，示例中Grandson先调用Son1的初始化，再调用Son2的初始化。

        2）方法重写与重载的区别
            重写(Override)：
                定义：子类定义与父类同名方法时完全覆盖父类方法
                特点：Python中常见，如子类重写__init__方法时会完全替代父类实现
                调用机制：通过子类实例调用方法时优先使用子类实现
            重载(Overload)：
                定义：同一类中存在多个同名方法，根据参数类型/数量不同调用不同实现
                Python支持：原生不支持，因为后定义的方法会覆盖前定义
                特殊实现：可通过*args和​**​kwargs模拟，或使用@singledispatch装饰器

        3）调用父类方法的三种方式
            直接调用：使用父类名显式调用，如Parent.__init__(self, name)
                    缺点：在多继承时需要手动调用每个父类方法
            super()指定类：super(Son1, self).__init__(name)
                    特点：按照MRO顺序自动查找下一个父类
            super()简写：Python3支持super().__init__(name)
                    优势：自动处理多继承情况，推荐使用

        4）MRO方法解析顺序
            C3算法：Python使用C3线性化算法确定方法调用顺序
            查看方法：通过类名.__mro__或类名.mro()查看继承顺序
            设计原则：
                子类优先于父类
                先继承的类优先于后继承的类
                保证所有父类只被调用一次

        5）多继承最佳实践
            参数传递：建议使用*args和​**​kwargs接收不定长参数
            super使用：在多层继承中统一使用super()保证初始化链完整
            避免陷阱：
                不要混用直接调用和super()调用
                注意钻石继承问题（父类被多次初始化）
                保持参数传递一致性

    2. 多继承中super调用有父类的被重写的方法 
        1）多继承与父类方法调用 
            继承关系：演示了Grandson类同时继承Son1和Son2，而Son1和Son2又都继承Parent类的多继承结构
            方法调用原则：通过哪个类创建实例对象，就调用该类的__init__方法，在方法内部可显式调用父类方法
            显式调用语法：使用Parent.init(self, name)形式时，必须将self作为第一个参数显式传递

        2）子类初始化方法中的父类调用 
            调用机制：子类通过Parent.init(self, name)显式调用父类初始化方法时：
            属性继承：父类的self.name = name操作会使子类对象自动获得name属性
            执行流程：先执行子类初始化代码，再调用父类初始化，最后返回子类剩余代码
            多层调用：当Grandson调用Son1.__init__时，会先执行Son1的初始化，Son1又调用Parent的初始化，形成调用链

        3）多继承中的初始化方法调用顺序 
            重复调用问题：当多个父类都继承同一个基类时，使用类名显式调用会导致基类方法被多次执行
            示例：Grandson创建时，Parent.__init__会被Son1和Son2各调用一次
            资源浪费：如果基类初始化涉及资源分配（如创建socket），会导致重复创建
            系统限制：进程默认最多打开1024个文件描述符，重复创建会
            调用顺序图示：形成Grandson→Son1→Parent和Grandson→Son2→Parent两条调用路径

        4）使用类名调用父类方法的缺点 快速耗尽资源
            主要缺陷：
                重复执行：顶层父类方法会被中间每个父类各调用一次
                资源浪费：如socket等系统资源会被重复创建
                参数传递：需要手动管理self参数传递，容易出错
            解决方案对比：
                优点：代码直观，明确知道调用的是哪个父类的方法
                缺点：在复杂多继承场景下会导致方法重复执行和资源浪费
                实际影响：当类继承层次较深或多继承关系复杂时，这种调用方式不再适用
            改进方案：使用super()代替显式类名调用
            参数处理：配合*args和**kwargs接收不定长参数
            调用优势：自动处理MRO顺序，避免方法重复调用
            语法形式：super().init(name, age, gender)或super(Grandson, self).init(...)
            MRO机制：通过print(Grandson.mro)可查看方法解析顺序

    3. 多继承与MRO顺序 
    1）多继承方法调用示例
        调用方式对比：
        直接调用父类名：明确指定调用哪个父类的方法，但会导致公共父类被多次调用
        使用super()：根据MRO顺序自动确定调用顺序，保证每个父类只被调用一次
        参数传递：
        多继承时必须使用*args, ​**​kwargs参数传递，避免参数不匹配报错
        示例中Parent类被调用了两次，说明直接调用父类名会导致重复执行
        
    2）super()调用机制详解 
        MRO核心机制：
            每个类都有__mro__属性，记录方法解析顺序
            顺序由C3算法决定，保证每个父类只出现一次
            示例中顺序为：Grandson -> Son1 -> Son2 -> Parent -> object
        super工作原理：
            不是简单调用直接父类，而是根据当前类在MRO中的位置决定下一个调用谁
            当在Son1中调用super()时，会查找Son1在MRO中的下一个类Son2
        调用链分析：
            Grandson初始化 -> Son1初始化 -> Son2初始化 -> Parent初始化
            每个super()调用只触发MRO中的下一个类方法

    3）三种调用方式对比
        方式区别：
            直接父类名：100%明确调用指定父类，但会导致公共父类重复执行
            super()无参数：按MRO顺序自动调用下一个类
            super(指定类)：从指定类开始按MRO顺序调用
        使用建议：
            简单继承推荐直接父类名，明确直观
            复杂多继承必须使用super()，避免重复调用
            需要跳过某些父类时使用super(指定类)
        执行次数：
            直接调用方式会导致Parent执行两次
            super()方式保证Parent只执行一次

    4）关键知识点总结
        C3算法特点：
            Python解释器内置的多继承解析算法
            保证每个类在继承链中只出现一次
            结果保存在类的__mro__属性中
        super核心要点：
            不是简单的"调用父类"，而是"调用MRO中的下一个类"
            调用链由MRO顺序决定，不受代码书写顺序影响
            在Parent中继续调用super()会指向object类
        实际应用：
            多继承时必须使用*args, ​**​kwargs传递参数
            通过打印__mro__可以验证调用顺序
            需要精细控制调用顺序时可指定super的起始类




