一、不定长参数 
    基本语法：在Python中定义函数或方法时，若参数数量不确定，可使用星号标记：
        单星号*args：接收多余的非关键字参数，以元组形式保存
        双星号​**​kwargs：接收多余的关键字参数，以字典形式保存
    变量命名规则：
        星号仅作为语法标记，实际变量名仍为args和kwargs
        变量名必须符合Python命名规范（字母/数字/下划线）
    参数处理机制：
        *args会收集所有未匹配的位置参数
        ​**​kwargs会收集所有未匹配的关键字参数
    例如调用func(1,2,a=3,b=4)时，1,2进入args，{'a':3,'b':4}进入kwargs

二、多继承与MRO顺序
    1. super()在多继承中的应用
        传统写法缺陷：
            需要显式调用每个父类的__init__方法
            必须完整传递所有参数，容易遗漏
        super()优势：
            自动按MRO顺序调用父类方法
            只需一次调用即可完成所有父类初始化
            必须配合不定长参数使用以确保参数传递完整
        实现要点：
            每个中间类都需要接受*args, ​**​kwargs参数
            子类调用时直接传递具体参数值
    2. MRO顺序验证
        查看方法：通过类名.__mro__属性查看方法解析顺序
        示例输出：
        调用流程：
        Grandson初始化时先调用Son1的__init__
        Son1通过super()调用Son2的__init__
        Son2通过super()调用Parent的__init__
        最终完成object的初始化

三、参数传递注意事项
    参数传递规则：
    固定参数必须放在参数列表最前面
    不定长参数必须放在参数列表最后面
    标准顺序：(self, 固定参数, *args, ​**​kwargs)
    常见错误：
    忘记在中间类中添加*args, ​**​kwargs参数
    错误地将具体参数放在不定长参数之后
    混淆*args和​**​kwargs的接收机制

四、不定长参数的定义 
    基本语法：定义函数时使用def test1(a, b, *args, ​**​kwargs)形式
    参数接收规则：
    必须参数：a和b必须传递对应实参（如11,22）
    多余位置参数：33,44等会被打包成元组存储在args中
    关键字参数：name="laowang"等会被打包成字典存储在kwargs中
    空值情况：当没有多余参数时，args为空元组()，kwargs为空字典{}

五、函数嵌套调用 
    参数传递问题：
    直接传递args和kwargs会导致它们被当作整体参数
    示例中test2(a, b, args, kwargs)会使args和kwargs被打包成元组元素
    输出表现：
    会得到(33,44,55,66), {'name':'laowang','age':18}这样的嵌套结构
    而非预期的参数自动分配到新函数的args和kwargs中
    
六、不定长参数的拆包 
    1. 不定长参数的定义与用法 
    核心概念：
        定义时的*和​**​表示参数收集
        调用时的*和​**​表示参数拆解

    2. *args的拆包演示与理解 
    拆包操作：
        使用*args会将元组拆解为独立参数
        示例中(33,44,55,66)被拆解为四个单独参数传递
    对比效果：
        未拆包：传递的是包含元组的元组((33,44,55,66),)
        拆包后：传递的是四个独立参数33,44,55,66

    3. **kwargs的拆包演示与理解 
    字典拆包：
        使用​**​kwargs会将字典拆解为键值对参数
        示例中{'name':'laowang','age':18}被拆解为name="laowang", age=18
    组合使用：
        test2(a, b, *args, ​**​kwargs)等效于直接传递所有原始参数
        实现了参数的原样传递效果

    4. 总结：不定长参数的接收与拆包 
    双重功能：
        定义时：*收集多余位置参数为元组，​**​收集关键字参数为字典
        调用时：*拆解元组为位置参数，​**​拆解字典为关键字参数
    使用场景：
        需要将接收到的参数原样传递给其他函数时
        需要处理不定数量参数的函数封装时
    记忆要点：
        定义收集，调用拆解
        单星处理位置参数，双星处理关键字参数
